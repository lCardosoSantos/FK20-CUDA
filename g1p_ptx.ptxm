/*
 * bls12_381: Arithmetic for BLS12-381
 * Copyright 2022-2023 Dag Arne Osvik
 * Copyright 2022-2023 Luan Cardoso dos Santos
 */

.version 8.1
.target sm_80
.address_size 64

#include "fp_cpy.ptxh"
#include "fp_x2.ptxh"
#include "fp_x3.ptxh"
#include "fp_x8.ptxh"
#include "fp_x12.ptxh"
#include "fp_add.ptxh"
#include "fp_sub.ptxh"
#include "fp_sqr.ptxh"
#include "fp_mul.ptxh"
#include "fp_reduce12.ptxh"

//////////////////////////////////////////////////////////////////////////////////////////
//
// g1p_ptx(uint32_t, g1p_t *, g1p_t *, const g1p_t *, const g1p_t *, const g1p_t *);
//
// Register usage in Fp operations:
//  x{2,4,8}:   a <- a.
//  x{3,12}:    a <- a. Modifies r.
//  reduce12:   a <- a. Modifies q and r.
//  sqr:        a <- b. Modifies q and r.
//  mul:        a <- b, c. Modifies q and r.
//  add:        a <- b, c. Modifies r.
//  sub:        a <- b, c. Modifies r.
//
//////////////////////////////////////////////////////////////////////////////////////////

.visible .func _Z7g1p_ptxiP5g1p_tS0_PKS_S2_(
        .param .u32 _Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_0,
        .param .b64 _Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_1,
        .param .b64 _Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_2,
        .param .b64 _Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_3,
        .param .b64 _Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_4
)
{
        //////// Register Allocation ////////

        // Function and return address selectors
        .reg .u32       %fun, %ret;

        // Function parameters (g1p_t *)
        .reg .b64       z, x, y;

        // Operand registers
        .reg .u64       a<10>, aa, ab, b<6>, c<6>; 

        // Temporaries (fp_t)
        .reg .u64       v<6>, w<6>, x<6>, y<6>, z<6>;

        // Extended temporaries
        .reg .u64       q<8>, r<7>;

        // Predicates: greater-than and non-zero
        .reg .pred      gt, nz;


        //////// Labels & Label Indices ////////

g1p_fun: .branchtargets
        g1p_dbl,
#define g1p_dbl_        0
        g1p_add,
#define g1p_add_        1
        g1p_addsub,
#define g1p_addsub_     2
        g1p_dbl_add,
#define g1p_dbl_add_    3
        g1p_dbl_add2;
#define g1p_dbl_add2_   4


fp_fun: .branchtargets
        fp_x2,
#define fp_x2_          0
        fp_x3,
#define fp_x3_          1
        fp_x4,
#define fp_x4_          2
        fp_x8,
#define fp_x8_          3
        fp_x12,
#define fp_x12_         4
        fp_add,
#define fp_add_         5
        fp_sub,
#define fp_sub_         6
        fp_sqr,
#define fp_sqr_         7
        fp_mul,
#define fp_mul_         8
        fp_reduce12,
#define fp_reduce12_    9
        fp_mma;
#define fp_mma_         10


fp_ret: .branchtargets
        dbl_x2,
#define dbl_x2_         0
        dbl_x3,
#define dbl_x3_         1
        dbl_x8,
#define dbl_x8_         2
        dbl_x12,
#define dbl_x12_        3
        add_x3,
#define add_x3_         4
        add_x12_0,
#define add_x12_0_      5
        add_x12_1;
#define add_x12_1_      6


        //////// G1p Function Selection ////////

        // Load parameters

        ld.param.u32    %fun, [_Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_0];
        ld.param.b64    z, [_Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_1];
        ld.param.b64    x, [_Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_2];
        ld.param.b64    y, [_Z7g1p_ptxiP5g1p_tS0_PKS_S2__param_3];

        // Jump to selected g1p function

        setp.gt.u32     gt, %fun, g1p_dbl_add2_;        // >last?
@!gt    brx.idx.uni     %fun, g1p_fun;

        // No valid g1p function chosen

        ret.uni;

        //////// G1p Functions ////////

        //// g1p_dbl ////

g1p_dbl:
        mov.u32         %fun, fp_x12_;
        mov.u32         %ret, dbl_x12_;
        brx.idx.uni     %fun, fp_fun;
    dbl_x12:

        mov.u32         %fun, fp_x3_;
        mov.u32         %ret, dbl_x3_;
        brx.idx.uni     %fun, fp_fun;
    dbl_x3:

        mov.u32         %fun, fp_x8_;
        mov.u32         %ret, dbl_x8_;
        brx.idx.uni     %fun, fp_fun;
    dbl_x8:

        mov.u32         %fun, fp_x2_;
        mov.u32         %ret, dbl_x2_;
        brx.idx.uni     %fun, fp_fun;
    dbl_x2:

        ret.uni;

        //// g1p_add ////

g1p_add:
    add_x3:
    add_x12_0:
    add_x12_1:
        ret.uni;

        //// g1p_addsub ////

g1p_addsub:
    addsub_x12_0:
    addsub_x3:
    addsub_x12_1:
        ret.uni;

        //// g1p_dbl_add ////

g1p_dbl_add:
        ret.uni;

        //// g1p_dbl_add2 ////

g1p_dbl_add2:
        ret.uni;

        //////// Fp Functions ////////

fp_x3:
        FP_X3(a, a, a);
        brx.idx.uni     %ret, fp_ret;

        // Space-saving const-multiplier code
fp_x12:
        FP_X3(a, a, a);
        bra.uni         fp_x4;
fp_x8:
        FP_X2(a, a, a);
fp_x4:
        FP_X2(a, a, a);
fp_x2:
        FP_X2(a, a, a);
        brx.idx.uni     %ret, fp_ret;

fp_add:
        FP_ADD(a, b, c, a);
        brx.idx.uni     %ret, fp_ret;

fp_sub:
        FP_SUB(a, b, c, a);
        brx.idx.uni     %ret, fp_ret;

fp_mma:
        bra.uni         fp_reduce12;

fp_sqr:
        FP_SQR(a, b);
        bra.uni         fp_reduce12;

fp_mul:
        FP_MUL(a, b, c);
//      bra.uni         fp_reduce12;    // Fall through to reduction

fp_reduce12:
        FP_REDUCE12(a);
        brx.idx.uni     %ret, fp_ret;
}

// vim: ts=8 et sw=8 si
